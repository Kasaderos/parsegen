
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">C:\Users\kasaderos\Documents\go\bnfparser\instruction.go (96.7%)</option>
				
				<option value="file1">C:\Users\kasaderos\Documents\go\bnfparser\main.go (0.0%)</option>
				
				<option value="file2">C:\Users\kasaderos\Documents\go\bnfparser\parser.go (0.0%)</option>
				
				<option value="file3">C:\Users\kasaderos\Documents\go\bnfparser\stack.go (40.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

var S = function{}

type tFunc func() bool

// lvalue = rvalue ~
// function = instructions
type function struct {
        typ      string
        name     string
        terminal tFunc
        funcs    []function
}

func (f *function) call() bool <span class="cov8" title="1">{
        return f.terminal()
}</span>

func (f *function) isTerminal() bool <span class="cov0" title="0">{
        return f.terminal != nil
}</span>

func back(stack *Stack, ret bool) <span class="cov8" title="1">{
        for !stack.Empty() </span><span class="cov8" title="1">{
                f := stack.Top().f
                i := stack.Top().i
                switch f.typ </span>{
                case "T":<span class="cov8" title="1">
                        stack.Pop()</span>
                case "L":<span class="cov8" title="1">
                        if ret </span><span class="cov8" title="1">{
                                if i+1 &lt; len(f.funcs) </span><span class="cov8" title="1">{
                                        stack.Pop()
                                        stack.Push(Frame{f, i + 1})
                                        stack.Push(Frame{f.funcs[i+1], i + 1})
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">stack.Pop()</span>
                case "N":<span class="cov8" title="1">
                        stack.Pop()
                        if !ret &amp;&amp; i+1 &lt; len(f.funcs) </span><span class="cov8" title="1">{
                                stack.Push(Frame{f.funcs[i+1], i + 1})
                                return
                        }</span>
                }
        }
}

func execute(f function) bool <span class="cov8" title="1">{
        stack := &amp;Stack{}
        stack.Push(Frame{f, 0})
        // register of return value
        ret := false

        for !stack.Empty() </span><span class="cov8" title="1">{
                f := stack.Top().f
                i := stack.Top().i
                switch f.typ </span>{
                case "N", "L":<span class="cov8" title="1">
                        // if non terminal is not empty push
                        if len(f.funcs) &gt; i </span><span class="cov8" title="1">{
                                stack.Push(Frame{f.funcs[i], i})
                        }</span>
                case "T":<span class="cov8" title="1">
                        ret = f.call()
                        back(stack, ret)</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

/*
        F()
*/

// LOGIC():
//    G(A())
//    G(B())

// A():
//   print('A')

// B():
//   print('B')

// C():
//   print('C')
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "io"
        "os"
)

var InputFile = flag.String("f", "file", "file where described BNF of parser")

func main() <span class="cov0" title="0">{
        flag.Parse()

        file, err := os.Open(*InputFile)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">bnf, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">_ = bnf</span>

        // if err = genParser(bnf); err != nil {
        //         fmt.Println(err)
        // }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bytes"
        "errors"
        "io"
)

var ErrEmptyLine = errors.New("empty line")

type Type int32

// if typ == string -&gt; value of string
type entity struct {
        typ Type

        // cycle parameters
        minRepeats int // -2 ~ 0..inf is kind of rule: ( ENTITY )*
        maxRepeats int // -1 ~ inf
        value      []byte
}

// Rule is a set of word like these:
// S ::= A B C
// lvalue S
// rvalue A B C
// type Rule struct {
//         Marked bool
//         lvalue entity
//         rvalue []entity
// }

// \n\n\n
func readLine(data *[]byte) ([]byte, error) <span class="cov0" title="0">{
        ind := bytes.Index(*data, []byte("\n"))
        if ind &lt; 0 </span><span class="cov0" title="0">{
                return nil, io.EOF
        }</span>
        <span class="cov0" title="0">line := (*data)[:ind]
        *data = (*data)[ind+1:]
        return line, nil</span>
}

// type state int32

// const (
//         Init state = iota
//         Final
// )

type Parser struct {
        line []byte
        i    int
        eof  bool

        err error
}

func NewParser(line []byte) *Parser <span class="cov0" title="0">{
        return &amp;Parser{line, 0, false, nil}
}</span>

func (p *Parser) cc() byte <span class="cov0" title="0">{
        return p.line[p.i]
}</span>

func (p *Parser) gp() int <span class="cov0" title="0">{
        return p.i
}</span>

func (p *Parser) slice(start, end int) []byte <span class="cov0" title="0">{
        return p.line[start:end]
}</span>

func (p *Parser) gc() bool <span class="cov0" title="0">{
        if p.i &gt;= len(p.line) </span><span class="cov0" title="0">{
                p.eof = true
                return true
        }</span>
        <span class="cov0" title="0">p.i++
        return false</span>
}

// ____FAFDFD__
func (p *Parser) Space(must bool) bool <span class="cov0" title="0">{
        exist := false
        for !p.eof </span><span class="cov0" title="0">{
                char := p.cc()
                if char == ' ' </span><span class="cov0" title="0">{
                        exist = true
                }</span> else<span class="cov0" title="0"> if must &amp;&amp; !exist </span><span class="cov0" title="0">{
                        p.err = errors.New("not space at line %d TODO")
                        return true
                }</span> else<span class="cov0" title="0"> {
                        return p.eof
                }</span>
                <span class="cov0" title="0">p.gc()</span>
        }
        <span class="cov0" title="0">return p.eof</span>
}

func isAlpha(b byte) bool <span class="cov0" title="0">{
        return b &gt;= 'a' &amp;&amp; b &lt;= 'z' || b &gt;= 'A' &amp;&amp; b &lt;= 'Z'
}</span>

func (p *Parser) Entity(lvalue bool) bool <span class="cov0" title="0">{
        start := p.gp()
        for !p.eof </span><span class="cov0" title="0">{
                char := p.cc()
                if !isAlpha(char) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">p.gc()</span>
        }
        <span class="cov0" title="0">end := p.gp()

        if start == end </span><span class="cov0" title="0">{
                if lvalue </span><span class="cov0" title="0">{
                        p.err = errors.New("lvalue can't be empty")
                        return true
                }</span>
                <span class="cov0" title="0">return p.eof</span>
        }

        // value := p.slice(start, end)
        // if lvalue {
        // p.Rule.lvalue.value = value
        // } else {
        // p.Rule.rvalue = append(p.Rule.rvalue, entity{value: value})
        // }
        <span class="cov0" title="0">return p.eof</span>
}

func (p *Parser) Lvalue() bool <span class="cov0" title="0">{
        return p.Entity(true)
}</span>

func (p *Parser) Delimeter() bool <span class="cov0" title="0">{
        first := p.cc()
        p.gc()
        second := p.cc()
        p.gc()

        if first != ':' || second != '=' </span><span class="cov0" title="0">{
                p.err = errors.New("invalid delimeter")
                return true
        }</span>

        <span class="cov0" title="0">return p.eof</span>
}

func (p *Parser) Rvalues() bool <span class="cov0" title="0">{
        return p.Space(true) || p.Rvalue() || p.Rvalues()
}</span>

// Any parses words that starts with 'starts' and ends with 'ends'
// If any has two or more ends, it stops in first 'ends' byte
func (p *Parser) Any(starts, ends byte) bool <span class="cov0" title="0">{
        if p.cc() != starts </span><span class="cov0" title="0">{
                p.err = errors.New("invalid start of 'any' entity")
                return true
        }</span>
        <span class="cov0" title="0">p.gc()

        start := p.gp()
        end := start
        ended := false
        for !p.eof </span><span class="cov0" title="0">{
                if p.cc() == ends </span><span class="cov0" title="0">{
                        ended = true
                        p.gc()
                        break</span>
                }
                <span class="cov0" title="0">p.gc()
                end = p.gp()</span>
        }

        <span class="cov0" title="0">if !ended </span><span class="cov0" title="0">{
                p.err = errors.New("invalid end of 'any' entity")
                return true
        }</span>

        <span class="cov0" title="0">if start == end </span><span class="cov0" title="0">{
                // feature 'any' might be empty inside
                return p.eof
        }</span>

        // newEntity := entity{
        //         typ:   String,
        //         value: p.slice(start, end),
        // }
        // p.Rule.rvalue = append(p.Rule.rvalue, newEntity)
        <span class="cov0" title="0">return p.eof</span>
}

func (p *Parser) String() bool <span class="cov0" title="0">{
        // without quotes inside (symbol '"')
        return p.Any('"', '"')
}</span>

func (p *Parser) Rvalue() bool <span class="cov0" title="0">{
        if !p.Entity(false) || !p.String() </span><span class="cov0" title="0">{
                return p.eof
        }</span>
        <span class="cov0" title="0">return true</span>
}

// // input data is a line without '\n'
// // rule := space lvalue space ":=" rvalues
// // lvalue := entity
// // rvalues := (space rvalue)(1:n)*
// // rvalue := entity | string
// // entity := word
// // string := &lt;"&gt; any &lt;"&gt; without quotes
// func lexic(line []byte) (*Rule, error) {
//         return nil, nil
//         // p := NewParser(line)

//         // p.Space(false)
//         // p.Lvalue()
//         // p.Space(true)
//         // p.Delimeter()
//         // p.Rvalues()
//         // return p.Rule, p.err
// }

// func getRule(line []byte) (*Rule, error) {
//         if len(line) &gt; 0 {
//                 return lexic(line)
//         }
//         return nil, ErrEmptyLine
// }

// // getRules parses from given bnf.
// func getRules(bnf []byte) ([]*Rule, error) {
//         rules := make([]*Rule, 0)
//         for {
//                 line, err := readLine(&amp;bnf)
//                 if err == io.EOF {
//                         break
//                 }

//                 rule, err := getRule(line)
//                 if err != nil &amp;&amp; err != ErrEmptyLine {
//                         return nil, err
//                 }
//                 rules = append(rules, rule)
//         }

//         // if err := syntax(rules); err != nil {
//         // return nil, err
//         // }
//         return rules, nil
// }

func genCC(ptr **byte) func() byte <span class="cov0" title="0">{
        return func() byte </span><span class="cov0" title="0">{
                return **ptr
        }</span>
}

func genGC(line []byte) (func(), *byte) <span class="cov0" title="0">{
        i := 0
        ptr := &amp;line[0]
        return func() </span><span class="cov0" title="0">{
                if i &gt;= len(line) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">i++
                ptr = &amp;line[i]</span>
        }, ptr
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import "fmt"

type Frame struct {
        f function
        i int
}

type Stack struct {
        p []Frame
}

func (stck *Stack) Push(s Frame) <span class="cov8" title="1">{
        stck.p = append(stck.p, s)
}</span>

func (stck *Stack) Pop() <span class="cov8" title="1">{
        stck.p = stck.p[:len(stck.p)-1]
}</span>

func (stck *Stack) Top() Frame <span class="cov8" title="1">{
        return stck.p[len(stck.p)-1]
}</span>

func (stck *Stack) Empty() bool <span class="cov8" title="1">{
        return len(stck.p) == 0
}</span>

func (stck *Stack) Print() <span class="cov0" title="0">{
        fmt.Println("-----")
        if stck.Empty() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, frame := range stck.p </span><span class="cov0" title="0">{
                fmt.Println("|", frame.f.funcs[frame.i].typ, frame.i, "|")
        }</span>
        <span class="cov0" title="0">fmt.Println("-----")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
